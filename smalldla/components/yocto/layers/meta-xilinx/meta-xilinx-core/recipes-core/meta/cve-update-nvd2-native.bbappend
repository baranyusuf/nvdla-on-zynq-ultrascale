# Backport nvd2 fixes from latest Scarthgap and mailing list:

# From: Peter Marko <peter.marko@siemens.com>
# Date: Fri, 28 Mar 2025 16:48:20 +0100
# Subject: [PATCH] cve-update-nvd2-native: handle missing vulnStatus
#
# There is a new CVE which is missing vulnStatus field:
# https://services.nvd.nist.gov/rest/json/cves/2.0?cveId=CVE-2025-2682
#
# This leads to:
# File: '<snip>/poky/meta/recipes-core/meta/cve-update-nvd2-native.bb', lineno: 336, function: update_db
#      0332:
#      0333:    accessVector = None
#      0334:    vectorString = None
#      0335:    cveId = elt['cve']['id']
#  *** 0336:    if elt['cve']['vulnStatus'] ==  "Rejected":
#      0337:        c = conn.cursor()
#      0338:        c.execute("delete from PRODUCTS where ID = ?;", [cveId])
#      0339:        c.execute("delete from NVD where ID = ?;", [cveId])
#      0340:        c.close()
# Exception: KeyError: 'vulnStatus'
#
# (From OE-Core rev: 2f242f2a269bb18aab703f685e27f9c3ba761db8)
#
# Signed-off-by: Peter Marko <peter.marko@siemens.com>
# Signed-off-by: Steve Sakoman <steve@sakoman.com>

# and

# From: Peter Marko <peter.marko@siemens.com>
# Date: Mon, 7 Apr 2025 11:35:57 +0200
# Subject: [PATCH] cve-update-nvd2-native: add workaround for json5 style list
#
# NVD responses changed to an invalid json between:
# * April 5, 2025 at 3:03:44 AM GMT+2
# * April 5, 2025 at 4:19:48 AM GMT+2
#
# The last response is since then in format
# {
#   "resultsPerPage": 625,
#   "startIndex": 288000,
#   "totalResults": 288625,
#   "format": "NVD_CVE",
#   "version": "2.0",
#   "timestamp": "2025-04-07T07:17:17.534",
#   "vulnerabilities": [
#     {...},
#     ...
#     {...},
#   ]
# }
#
# ...
#
# There was no announcement about json format of API v2.0 by nvd.
# Also this happens only if whole database is queried (database update is
# fine, even when multiple pages as queried).
# And lastly it's only the cve list, all other lists inside are fine.
# So this looks like a bug in NVD 2.0 introduced with some update.
#
# Patch this with simple character deletion for now and let's monitor the
# situation and possibly switch to json5 in the future.
# Note that there is no native json5 support in python, we'd have to use
# one of external libraries for it.
#
# Signed-off-by: Peter Marko <peter.marko@siemens.com>

def update_db_file(db_tmp_file, d, database_time):
    """
    Update the given database file
    """
    import bb.utils, bb.progress
    import datetime
    import sqlite3
    import json

    # Connect to database
    conn = sqlite3.connect(db_tmp_file)
    initialize_db(conn)

    req_args = {'startIndex' : 0}

    incr_update_threshold = int(d.getVar("CVE_DB_INCR_UPDATE_AGE_THRES"))
    if database_time != 0:
        database_date = datetime.datetime.fromtimestamp(database_time, tz=datetime.timezone.utc)
        today_date = datetime.datetime.now(tz=datetime.timezone.utc)
        delta = today_date - database_date
        if incr_update_threshold == 0:
            bb.note("CVE database: forced full update")
        elif delta < datetime.timedelta(seconds=incr_update_threshold):
            bb.note("CVE database: performing partial update")
            # The maximum range for time is 120 days
            if delta > datetime.timedelta(days=120):
                bb.error("CVE database: Trying to do an incremental update on a larger than supported range")
            req_args['lastModStartDate'] = database_date.isoformat()
            req_args['lastModEndDate'] = today_date.isoformat()
        else:
            bb.note("CVE database: file too old, forcing a full update")
    else:
        bb.note("CVE database: no preexisting database, do a full download")

    with bb.progress.ProgressHandler(d) as ph, open(os.path.join(d.getVar("TMPDIR"), 'cve_check'), 'a') as cve_f:

        bb.note("Updating entries")
        index = 0
        url = d.getVar("NVDCVE_URL")
        api_key = d.getVar("NVDCVE_API_KEY") or None
        attempts = int(d.getVar("CVE_DB_UPDATE_ATTEMPTS"))

        # Recommended by NVD
        wait_time = 6
        if api_key:
            wait_time = 2

        while True:
            req_args['startIndex'] = index
            raw_data = nvd_request_next(url, attempts, api_key, req_args, wait_time)
            if raw_data is None:
                # We haven't managed to download data
                return False

            # hack for json5 style responses
            if raw_data[-3:] == ',]}':
                bb.note("Removing trailing ',' from nvd response")
                raw_data = raw_data[:-3] + ']}'

            data = json.loads(raw_data)

            index = data["startIndex"]
            total = data["totalResults"]
            per_page = data["resultsPerPage"]
            bb.note("Got %d entries" % per_page)
            for cve in data["vulnerabilities"]:
               update_db(conn, cve)

            index += per_page
            ph.update((float(index) / (total+1)) * 100)
            if index >= total:
               break

            # Recommended by NVD
            time.sleep(wait_time)

        # Update success, set the date to cve_check file.
        cve_f.write('CVE database update : %s\n\n' % datetime.date.today())

    conn.commit()
    conn.close()
    return True

def update_db(conn, elt):
    """
    Update a single entry in the on-disk database
    """

    accessVector = None
    vectorString = None
    cveId = elt['cve']['id']
    if elt['cve'].get('vulnStatus') ==  "Rejected":
        c = conn.cursor()
        c.execute("delete from PRODUCTS where ID = ?;", [cveId])
        c.execute("delete from NVD where ID = ?;", [cveId])
        c.close()
        return
    cveDesc = ""
    for desc in elt['cve']['descriptions']:
        if desc['lang'] == 'en':
            cveDesc = desc['value']
    date = elt['cve']['lastModified']
    try:
        accessVector = elt['cve']['metrics']['cvssMetricV2'][0]['cvssData']['accessVector']
        vectorString = elt['cve']['metrics']['cvssMetricV2'][0]['cvssData']['vectorString']
        cvssv2 = elt['cve']['metrics']['cvssMetricV2'][0]['cvssData']['baseScore']
    except KeyError:
        cvssv2 = 0.0
    cvssv3 = None
    try:
        accessVector = accessVector or elt['cve']['metrics']['cvssMetricV30'][0]['cvssData']['attackVector']
        vectorString = vectorString or elt['cve']['metrics']['cvssMetricV30'][0]['cvssData']['vectorString']
        cvssv3 = elt['cve']['metrics']['cvssMetricV30'][0]['cvssData']['baseScore']
    except KeyError:
        pass
    try:
        accessVector = accessVector or elt['cve']['metrics']['cvssMetricV31'][0]['cvssData']['attackVector']
        vectorString = vectorString or elt['cve']['metrics']['cvssMetricV31'][0]['cvssData']['vectorString']
        cvssv3 = cvssv3 or elt['cve']['metrics']['cvssMetricV31'][0]['cvssData']['baseScore']
    except KeyError:
        pass
    cvssv3 = cvssv3 or 0.0
    try:
        accessVector = accessVector or elt['cve']['metrics']['cvssMetricV40'][0]['cvssData']['attackVector']
        vectorString = vectorString or elt['cve']['metrics']['cvssMetricV40'][0]['cvssData']['vectorString']
        cvssv4 = elt['cve']['metrics']['cvssMetricV40'][0]['cvssData']['baseScore']
    except KeyError:
        cvssv4 = 0.0
    accessVector = accessVector or "UNKNOWN"
    vectorString = vectorString or "UNKNOWN"

    conn.execute("insert or replace into NVD values (?, ?, ?, ?, ?, ?, ?, ?)",
                [cveId, cveDesc, cvssv2, cvssv3, cvssv4, date, accessVector, vectorString]).close()

    try:
        # Remove any pre-existing CVE configuration. Even for partial database
        # update, those will be repopulated. This ensures that old
        # configuration is not kept for an updated CVE.
        conn.execute("delete from PRODUCTS where ID = ?", [cveId]).close()
        for config in elt['cve']['configurations']:
            # This is suboptimal as it doesn't handle AND/OR and negate, but is better than nothing
            for node in config["nodes"]:
                parse_node_and_insert(conn, node, cveId)
    except KeyError:
        bb.note("CVE %s has no configurations" % cveId)
